apply plugin: 'com.android.application'

apply plugin: 'jacoco'

jacoco {
    toolVersion = "$jacocoVersion"
    reportsDir = file("$project.buildDir/customJacocoReportDir")
}

tasks.withType(Test) {
    jacoco.includeNoLocationClasses = true
}

ext {
    limits = [
            'instruction': 93,
            'branch'     : 88,
            'Line'       : 0,
            'complexity' : 84,
            'Method'     : 0,
            'Class'      : 0 //TODO - 100%
    ]

}

project.ext {
    codeCoverageMetrics = [:]
}

task publishToGraphana(type:Exec, dependsOn:'buildShellScript' ) {
    workingDir project.buildDir
    commandLine 'sh', './report.sh'
}

task buildShellScript(dependsOn:'parseJacocoReport' ) {
    doLast {
        println(project.codeCoverageMetrics)

        def awsCommand = 'aws cloudwatch put-metric-data --namespace fusion-production-android';

        project.codeCoverageMetrics.each {

            awsCommand += ' '
            awsCommand += '--dimensions Name=Coverage --metric-name'
            awsCommand += ' '
            awsCommand += it.key
            awsCommand += ' '
            awsCommand += '--value'
            awsCommand += ' '
            awsCommand += it.value
        }

        println(awsCommand)
        File file = new File("$project.buildDir/report.sh");
        file.text = awsCommand
    }
}

task parseJacocoReport(dependsOn:'jacocoTestReport' ) {
    doLast {
        def report = file("$project.buildDir/customJacocoReportDir/jacocoTestReport/jacocoTestReport.xml")
        logger.lifecycle("Checking coverage results: ${report}")

        def parser = new XmlParser()
        parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
        parser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
        def results = parser.parse(report)
        def counters = results.counter

        //getting line coverage

        def lineNode = counters.find { it.'@type'.equals('LINE') }
        def lineMissed = lineNode.@missed as Double
        def lineCovered = lineNode.@covered as Double
        def linePercentage = ((lineCovered / (lineCovered + lineMissed)) * 100).round(2)
        logger.lifecycle("Checking line results: ${linePercentage}")

        def classNode = counters.find { it.'@type'.equals('CLASS') }
        def classMissed = classNode.@missed as Double
        def classCovered = classNode.@covered as Double
        def classPercentage = ((classCovered / (classCovered + classMissed)) * 100).round(2)
        logger.lifecycle("Checking line results: ${classPercentage}")

        def methodNode = counters.find { it.'@type'.equals('METHOD') }
        def methodMissed = methodNode.@missed as Double
        def methodCovered = methodNode.@covered as Double
        def methodPercentage = ((methodCovered / (methodCovered + methodMissed)) * 100).round(2)
        logger.lifecycle("Checking line results: ${methodPercentage}")


        //def metrics = [:]
        project.codeCoverageMetrics << [
                'Line'       : linePercentage,
                'Method'     : methodPercentage,
                'Class'      : classPercentage
        ]


        def failures = []
        project.codeCoverageMetrics.each {
            def limit = limits[it.key]
            if (it.value < limit) {
                failures.add("- ${it.key} coverage rate is: ${it.value}%, minimum is ${limit}%")
            }
        }

        if (failures) {
            logger.quiet("------------------ Code Coverage Failed -----------------------")
            failures.each {
                logger.quiet(it)
            }
            logger.quiet("---------------------------------------------------------------")
            throw new GradleException("Code coverage failed")
        } else {
            logger.quiet("Passed Code Coverage Checks")
        }

        println(project.codeCoverageMetrics)
    }
}

task jacocoTestReport(type: JacocoReport, dependsOn: ['testDebugUnitTest', 'createDebugCoverageReport']) {

    reports {
        xml.enabled = true
        html.enabled = true
    }

    def fileFilter = ['**/R.class', '**/R$*.class', '**/BuildConfig.*', '**/Manifest*.*', '**/*Test*.*', 'android/**/*.*']
    def debugTree = fileTree(dir: "$project.buildDir/intermediates/classes/debug", excludes: fileFilter)
    def mainSrc = "$project.projectDir/src/main/java"

    sourceDirectories = files([mainSrc])
    classDirectories = files([debugTree])
    executionData = fileTree(dir: project.buildDir, includes: [
            'jacoco/testDebugUnitTest.exec', 'outputs/code-coverage/connected/*coverage.ec'
    ])
}

parseJacocoReport.mustRunAfter jacocoTestReport
buildShellScript.mustRunAfter parseJacocoReport
publishToGraphana.mustRunAfter buildShellScript

android {
    compileSdkVersion 27
    defaultConfig {
        applicationId "com.autodesk.helloworld"
        minSdkVersion 15
        targetSdkVersion 27
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }
    buildTypes {

        debug {
            testCoverageEnabled true
        }

        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }

    testOptions {
        execution 'ANDROID_TEST_ORCHESTRATOR'
        animationsDisabled true
        unitTests.returnDefaultValues = true

        unitTests {
            includeAndroidResources = true
        }
        unitTests.all {
            jacoco {
                includeNoLocationClasses = true
            }
        }
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation 'com.android.support.constraint:constraint-layout:1.1.0'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.1'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'
}
